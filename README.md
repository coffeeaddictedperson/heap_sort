# Heap sort: Пірамідальне сортування, або сортування кучею

## Принцип роботи 

Масив в цьому випадку розглядається, як бінарне дерево, де доступ до ключів це 2^n + k 

Головний принцип, винесення максимального елементу в корінь дерева (під-дерева) 
Алгоритм розбитий на дві під-частини, схожих за принципом. 
Початкова підготовка і поступове зменншення невідсортованої частини, так як останний елемент, буде таким, що вже знаходиться на своєму місці.
Сортування починається з найнижчих рівнів і в процесі роботи алгоритму, найбільше значення “спливає” в корінь піддерев.

В результаті кожної ітерації найбільше значення опиняється на позиції “0”. Його міняють місцями з останнім елементом не-відсортованої ще частини. Останній же елемент, який є “коренем” спускають, допоки дерево знов не набуде вигляду, де корінь піддерева, завше більший за дочірні ноди

Приклад візуалізації https://www.cs.usfca.edu/~galles/visualization/HeapSort.html


## Приклад імплементації на Python

Див. heap_sort.py   

## Особливості

### Переваги 
- час роботи в найгіршому випадку  O(n log n)
- Вимагає O(1) додаткової памʼяті

### Недоліки

- нестійкий — для забезпечення стійкості потрібно розширювати ключ, 
- на майже відсортованих даних працює так само довго, як і на хаотичних даних;
- складний в реалізації (і розумінні);
- на одному кроці вибірку доводиться робити хаотично по всій довжині масиву — тому алгоритм погано поєднується з кешуванням і  "файлом довантаження" віртуальної пам'яті;
- методу потрібно «миттєвий» прямий доступ;
- не працює на зв'язаних списках та інших структурах пам'яті послідовного доступу.

## Висновки 

Алгоритм буде ефективнішим на великих обсягах даних.
Якщо даних небагато — сортування Шелла його обжене.


